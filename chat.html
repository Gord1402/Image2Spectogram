<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultrasonic Chat</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background: #1e1e1e;
      color: #e0e0e0;
    }
    .container {
      max-width: 1000px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      color: #64b5f6;
    }
    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    input, button, select {
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #333;
      color: white;
    }
    button {
      background: #1976d2;
      cursor: pointer;
    }
    button:hover {
      background: #1565c0;
    }
    button:disabled {
      background: #555;
      cursor: not-allowed;
    }
    .chat-box {
      height: 300px;
      overflow-y: auto;
      background: #2a2a2a;
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 15px;
      white-space: pre-wrap;
    }
    .spectrogram {
      width: 100%;
      height: 200px;
      background: #000;
      border-radius: 6px;
      margin-bottom: 15px;
      position: relative;
    }
    #canvas {
      display: block;
    }
    .status {
      color: #90caf9;
      font-size: 0.9em;
      margin-top: 10px;
    }
    .self { color: #81c784; }
    .other { color: #4fc3f7; }
    .error { color: #e57373; }
    .debug {
      font-size: 0.8em;
      margin-top: 10px;
      color: #aaa;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ”Š Ultrasonic Chat (15â€“20 kHz)</h1>
    
    <div class="controls">
      <input type="text" id="username" placeholder="Your name" value="User">
      <button id="startBtn">Start Listening & Transmitting</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>

    <div class="chat-box" id="chatBox"></div>

    <div class="spectrogram">
      <canvas id="canvas"></canvas>
    </div>

    <div class="controls">
      <input type="text" id="messageInput" placeholder="Type a message..." disabled>
      <button id="sendBtn" disabled>Send via Ultrasound</button>
    </div>

    <div class="status" id="status">Status: Not started</div>
    <div class="debug" id="debug"></div>
  </div>

  <script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONFIGURATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SAMPLE_RATE = 48000;
const FREQ_MIN = 15000;
const FREQ_MAX = 20000;
const N_SUBCARRIERS = 32; // Must divide SAMPLE_RATE nicely
const SYMBOL_DURATION_MS = 50; // ms per symbol
const SYMBOL_SAMPLES = Math.round((SYMBOL_DURATION_MS / 1000) * SAMPLE_RATE);
const PREAMBLE_LENGTH = 16; // symbols
const CRC8_POLY = 0x07; // CRC-8-CCITT

// Derived
const FREQ_SPACING = (FREQ_MAX - FREQ_MIN) / N_SUBCARRIERS;
const FFT_SIZE = 1024;
const HOP_SIZE = 256;
const BUFFER_DURATION_MS = 1000; // mic buffer for sync
const BUFFER_SAMPLES = Math.round((BUFFER_DURATION_MS / 1000) * SAMPLE_RATE);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UTILS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function crc8(data) {
  let crc = 0;
  for (let byte of data) {
    crc ^= byte;
    for (let i = 0; i < 8; i++) {
      crc = (crc << 1) ^ ((crc & 0x80) ? CRC8_POLY : 0);
    }
  }
  return crc & 0xFF;
}

function generatePreamble(clientId) {
  // Unique pseudo-random preamble per client (32 bits)
  const seed = clientId.charCodeAt(0) * 31 + clientId.length;
  const preamble = new Array(PREAMBLE_LENGTH).fill(0);
  let state = seed;
  for (let i = 0; i < PREAMBLE_LENGTH; i++) {
    state = (state * 1664525 + 1013904223) >>> 0; // LCG
    preamble[i] = (state & 1) ? 1 : -1;
  }
  return preamble;
}

function binaryToBytes(binStr) {
  const bytes = [];
  for (let i = 0; i < binStr.length; i += 8) {
    const chunk = binStr.slice(i, i + 8).padEnd(8, '0');
    bytes.push(parseInt(chunk, 2));
  }
  return new Uint8Array(bytes);
}

function bytesToBinary(bytes) {
  return Array.from(bytes)
    .map(b => b.toString(2).padStart(8, '0'))
    .join('');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AUDIO PROCESSING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class UltrasonicModem {
  constructor() {
    this.audioCtx = null;
    this.oscillators = [];
    this.stream = null;
    this.analyser = null;
    this.microphone = null;
    this.scriptProcessor = null;
    this.clientId = Math.random().toString(36).substr(2, 6);
    this.preamble = generatePreamble(this.clientId);
    this.receiveBuffer = new Float32Array(BUFFER_SAMPLES);
    this.receiveIndex = 0;
    this.isTransmitting = false;
    this.lastRxTime = 0;
    this.stats = { tx: 0, rx: 0, crcErr: 0, syncErr: 0 };
  }

  async init() {
    try {
      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
      
      // Setup mic
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: { 
        sampleRate: SAMPLE_RATE,
        channelCount: 1,
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }});
      
      this.microphone = this.audioCtx.createMediaStreamSource(this.stream);
      this.analyser = this.audioCtx.createAnalyser();
      this.analyser.fftSize = FFT_SIZE;
      this.microphone.connect(this.analyser);
      
      // Setup script processor for raw samples
      this.scriptProcessor = this.audioCtx.createScriptProcessor(HOP_SIZE, 1, 1);
      this.scriptProcessor.onaudioprocess = (e) => this.processAudio(e);
      this.microphone.connect(this.scriptProcessor);
      
      return true;
    } catch (err) {
      console.error("Audio init failed:", err);
      return false;
    }
  }

  processAudio(e) {
    if (!this.isListening) return;
    
    const input = e.inputBuffer.getChannelData(0);
    // Circular buffer
    const remaining = this.receiveBuffer.length - this.receiveIndex;
    if (input.length <= remaining) {
      this.receiveBuffer.set(input, this.receiveIndex);
    } else {
      this.receiveBuffer.set(input.slice(0, remaining), this.receiveIndex);
      this.receiveBuffer.set(input.slice(remaining), 0);
    }
    this.receiveIndex = (this.receiveIndex + input.length) % this.receiveBuffer.length;
    
    // Try to decode every ~50ms
    if (performance.now() - this.lastRxTime > 40) {
      this.lastRxTime = performance.now();
      this.decode();
    }
  }

  startListening() {
    this.isListening = true;
    this.receiveIndex = 0;
    this.receiveBuffer.fill(0);
  }

  stopListening() {
    this.isListening = false;
  }

  // â”€â”€â”€ ENCODING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  encodeMessage(text, username) {
    // Format: [username]\0[text]\0
    const payload = `${username}\0${text}\0`;
    const encoder = new TextEncoder();
    const data = encoder.encode(payload);
    
    // Add CRC-8
    const crc = crc8(data);
    const packet = new Uint8Array(data.length + 1);
    packet.set(data);
    packet[data.length] = crc;

    // Convert to binary string
    let binStr = bytesToBinary(packet);
    
    // Add safety bits: duplicate each bit (majority voting)
    binStr = binStr.split('').map(b => b + b + b).join('');

    // Pad to multiple of N_SUBCARRIERS
    const padLen = (N_SUBCARRIERS - (binStr.length % N_SUBCARRIERS)) % N_SUBCARRIERS;
    binStr += '0'.repeat(padLen);

    // Convert to grid: each row = one symbol (N_SUBCARRIERS bits)
    const symbols = [];
    for (let i = 0; i < binStr.length; i += N_SUBCARRIERS) {
      const row = binStr.slice(i, i + N_SUBCARRIERS).split('').map(b => parseInt(b));
      symbols.push(row);
    }

    return symbols;
  }

  async transmit(symbols) {
    if (this.isTransmitting) return;
    this.isTransmitting = true;
    this.stats.tx++;

    try {
      // Create audio buffer
      const totalSamples = (PREAMBLE_LENGTH + symbols.length) * SYMBOL_SAMPLES;
      const buffer = this.audioCtx.createBuffer(1, totalSamples, SAMPLE_RATE);
      const channel = buffer.getChannelData(0);

      let offset = 0;

      // Encode preamble (BPSK)
      for (let i = 0; i < PREAMBLE_LENGTH; i++) {
        const phase = this.preamble[i] > 0 ? 0 : Math.PI;
        this._generateTone(channel, offset, SYMBOL_SAMPLES, FREQ_MIN + FREQ_SPACING * 4, phase);
        offset += SYMBOL_SAMPLES;
      }

      // Encode data symbols
      for (const symbol of symbols) {
        // Build FFT bin
        const fftIn = new Float32Array(FFT_SIZE).fill(0);
        
        // Map bits to subcarriers (1 = +1, 0 = -1)
        for (let k = 0; k < N_SUBCARRIERS; k++) {
          const freq = FREQ_MIN + (k + 0.5) * FREQ_SPACING;
          const binIndex = Math.round((freq / SAMPLE_RATE) * FFT_SIZE);
          if (binIndex < FFT_SIZE/2) {
            fftIn[binIndex] = symbol[k] ? 1 : -1;
          }
        }

        // Inverse FFT â†’ time domain
        const timeDomain = this._inverseFFT(fftIn);
        
        // Normalize & copy to buffer
        const max = Math.max(...timeDomain.map(Math.abs));
        for (let i = 0; i < SYMBOL_SAMPLES && offset + i < totalSamples; i++) {
          channel[offset + i] = (timeDomain[i % timeDomain.length] / max) * 0.3;
        }
        offset += SYMBOL_SAMPLES;
      }

      // Play
      const source = this.audioCtx.createBufferSource();
      source.buffer = buffer;
      source.connect(this.audioCtx.destination);
      source.start();
      
      await new Promise(resolve => {
        source.onended = () => {
          this.isTransmitting = false;
          resolve();
        };
      });
    } catch (err) {
      console.error("Transmit error:", err);
      this.isTransmitting = false;
    }
  }

  _generateTone(channel, start, len, freq, phase) {
    const phaseInc = 2 * Math.PI * freq / SAMPLE_RATE;
    for (let i = 0; i < len; i++) {
      channel[start + i] = 0.5 * Math.sin(phase + i * phaseInc);
    }
  }

  _inverseFFT(real) {
    // Simple real-input IFFT (only positive freqs)
    const n = real.length;
    const imag = new Float32Array(n);
    const out = new Float32Array(n);
    
    // Perform FFT (using Cooley-Tukey)
    this._fft(real, imag, out, new Float32Array(n), 1);
    
    // Normalize and take real part
    for (let i = 0; i < n; i++) {
      out[i] /= n;
    }
    return out;
  }

  _fft(re, im, outRe, outIm, direction) {
    // In-place FFT (decimation in time)
    const n = re.length;
    if (n <= 1) return;
    
    const evenRe = new Float32Array(n/2);
    const evenIm = new Float32Array(n/2);
    const oddRe = new Float32Array(n/2);
    const oddIm = new Float32Array(n/2);
    
    for (let i = 0; i < n/2; i++) {
      evenRe[i] = re[2*i];
      evenIm[i] = im[2*i];
      oddRe[i] = re[2*i+1];
      oddIm[i] = im[2*i+1];
    }
    
    this._fft(evenRe, evenIm, outRe, outIm, direction);
    this._fft(oddRe, oddIm, outRe, outIm, direction);
    
    for (let k = 0; k < n/2; k++) {
      const angle = direction * 2 * Math.PI * k / n;
      const wRe = Math.cos(angle);
      const wIm = Math.sin(angle);
      
      const tRe = wRe * oddRe[k] - wIm * oddIm[k];
      const tIm = wRe * oddIm[k] + wIm * oddRe[k];
      
      re[k] = evenRe[k] + tRe;
      im[k] = evenIm[k] + tIm;
      re[k + n/2] = evenRe[k] - tRe;
      im[k + n/2] = evenIm[k] - tIm;
    }
  }

  // â”€â”€â”€ DECODING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  decode() {
    if (this.isTransmitting) return;

    // Convert circular buffer to linear for processing
    const data = new Float32Array(BUFFER_SAMPLES);
    if (this.receiveIndex === 0) {
      data.set(this.receiveBuffer);
    } else {
      data.set(this.receiveBuffer.slice(this.receiveIndex));
      data.set(this.receiveBuffer.slice(0, this.receiveIndex), BUFFER_SAMPLES - this.receiveIndex);
    }

    // Find preamble via cross-correlation
    const corr = this._crossCorrelate(data, this.preamble, FREQ_MIN + FREQ_SPACING * 4);
    const maxIdx = corr.indexOf(Math.max(...corr));
    const maxVal = corr[maxIdx];

    // Threshold: > 0.6 indicates sync
    if (maxVal < 0.6 || maxIdx < SYMBOL_SAMPLES) return;

    // Decode from sync point
    try {
      const symbols = [];
      let offset = maxIdx;

      // Skip preamble
      offset += PREAMBLE_LENGTH * SYMBOL_SAMPLES;

      // Read symbols until end or timeout
      while (offset + SYMBOL_SAMPLES <= data.length) {
        const window = data.slice(offset, offset + SYMBOL_SAMPLES);
        const freqBins = this._fftMagnitude(window);
        
        // Extract subcarriers
        const symbol = new Array(N_SUBCARRIERS);
        for (let k = 0; k < N_SUBCARRIERS; k++) {
          const freq = FREQ_MIN + (k + 0.5) * FREQ_SPACING;
          const binIndex = Math.round((freq / SAMPLE_RATE) * (FFT_SIZE/2));
          symbol[k] = freqBins[binIndex] > 0.1 ? 1 : 0;
        }
        symbols.push(symbol);
        offset += SYMBOL_SAMPLES;
      }

      if (symbols.length === 0) return;

      // Convert grid â†’ binary string
      let binStr = '';
      for (const symbol of symbols) {
        binStr += symbol.join('');
      }

      // Remove safety bits (majority vote per triplet)
      let cleaned = '';
      for (let i = 0; i < binStr.length; i += 3) {
        const triplet = binStr.slice(i, i+3);
        const ones = triplet.split('1').length - 1;
        cleaned += ones >= 2 ? '1' : '0';
      }

      // Convert to bytes
      const bytes = binaryToBytes(cleaned);
      if (bytes.length < 2) return;

      // Check CRC
      const payload = bytes.slice(0, -1);
      const receivedCrc = bytes[bytes.length - 1];
      const calculatedCrc = crc8(payload);
      
      if (receivedCrc !== calculatedCrc) {
        this.stats.crcErr++;
        return;
      }

      // Parse message
      const decoder = new TextDecoder();
      const str = decoder.decode(payload);
      const parts = str.split('\0');
      if (parts.length < 2) return;
      
      const username = parts[0] || 'Anonymous';
      const message = parts[1] || '';
      
      // Avoid echo
      if (username === document.getElementById('username').value) return;

      this.stats.rx++;
      this.onMessageReceived?.(username, message);

    } catch (err) {
      this.stats.syncErr++;
      console.warn("Decode error:", err.message);
    }
  }

  _crossCorrelate(signal, preamble, freq) {
    const corr = new Array(signal.length - SYMBOL_SAMPLES).fill(0);
    const ref = new Float32Array(SYMBOL_SAMPLES);
    this._generateTone(ref, 0, SYMBOL_SAMPLES, freq, 0);
    
    // Normalize ref
    const refRms = Math.sqrt(ref.reduce((sum, x) => sum + x*x, 0) / ref.length);
    ref.forEach((v, i) => ref[i] = v / refRms);

    for (let i = 0; i < corr.length; i++) {
      let sum = 0;
      for (let j = 0; j < SYMBOL_SAMPLES; j++) {
        sum += signal[i + j] * ref[j];
      }
      corr[i] = Math.abs(sum) / SYMBOL_SAMPLES;
    }
    return corr;
  }

  _fftMagnitude(signal) {
    const n = FFT_SIZE;
    const re = new Float32Array(n);
    const im = new Float32Array(n);
    
    // Zero-pad
    for (let i = 0; i < Math.min(signal.length, n); i++) {
      re[i] = signal[i];
    }
    
    // FFT
    this._fft(re, im, new Float32Array(n), new Float32Array(n), -1);
    
    // Magnitude spectrum
    const mag = new Float32Array(n/2);
    for (let i = 0; i < n/2; i++) {
      mag[i] = Math.sqrt(re[i]*re[i] + im[i]*im[i]) / n;
    }
    return mag;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UI & APP LOGIC
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class ChatApp {
  constructor() {
    this.modem = new UltrasonicModem();
    this.chatBox = document.getElementById('chatBox');
    this.statusEl = document.getElementById('status');
    this.debugEl = document.getElementById('debug');
    this.usernameInput = document.getElementById('username');
    this.messageInput = document.getElementById('messageInput');
    
    this.setupEventListeners();
    this.drawSpectrogram();
  }

  setupEventListeners() {
    document.getElementById('startBtn').onclick = () => this.start();
    document.getElementById('stopBtn').onclick = () => this.stop();
    document.getElementById('sendBtn').onclick = () => this.sendMessage();
    this.messageInput.onkeypress = (e) => {
      if (e.key === 'Enter') this.sendMessage();
    };
  }

  async start() {
    const ok = await this.modem.init();
    if (!ok) {
      this.updateStatus("âŒ Microphone access denied or not supported", 'error');
      return;
    }

    this.modem.onMessageReceived = (username, message) => {
      this.addMessage(username, message, 'other');
    };

    this.modem.startListening();
    
    document.getElementById('startBtn').disabled = true;
    document.getElementById('stopBtn').disabled = false;
    this.messageInput.disabled = false;
    document.getElementById('sendBtn').disabled = false;
    
    this.updateStatus("âœ… Listening & transmitting enabled");
    this.drawSpectrogram(); // start animation
  }

  stop() {
    this.modem.stopListening();
    if (this.modem.stream) {
      this.modem.stream.getTracks().forEach(t => t.stop());
    }
    if (this.modem.audioCtx) {
      this.modem.audioCtx.close();
    }

    document.getElementById('startBtn').disabled = false;
    document.getElementById('stopBtn').disabled = true;
    this.messageInput.disabled = true;
    document.getElementById('sendBtn').disabled = true;
    
    this.updateStatus("â¹ï¸ Stopped");
  }

  async sendMessage() {
    const text = this.messageInput.value.trim();
    if (!text) return;

    const username = this.usernameInput.value || 'User';
    const symbols = this.modem.encodeMessage(text, username);
    await this.modem.transmit(symbols);

    this.addMessage(username, text, 'self');
    this.messageInput.value = '';
    this.updateStatus(`ğŸ“¡ Sent: "${text}"`);
  }

  addMessage(username, message, cls) {
    const now = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    const line = `[${now}] <span class="${cls}">${username}:</span> ${message}\n`;
    this.chatBox.innerHTML += line;
    this.chatBox.scrollTop = this.chatBox.scrollHeight;
  }

  updateStatus(text, cls = '') {
    this.statusEl.textContent = `Status: ${text}`;
    this.statusEl.className = 'status ' + cls;
  }

  updateDebug() {
    const s = this.modem.stats;
    this.debugEl.textContent = 
      `TX: ${s.tx} | RX: ${s.rx} | CRC Err: ${s.crcErr} | Sync Err: ${s.syncErr}`;
  }

  drawSpectrogram() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const analyser = this.modem.analyser;
    
    if (!analyser) {
      requestAnimationFrame(() => this.drawSpectrogram());
      return;
    }

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    
    const draw = () => {
      requestAnimationFrame(draw);
      
      analyser.getByteFrequencyData(dataArray);
      
      // Clear
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw spectrogram lines (only 15-20 kHz range)
      const minBin = Math.round((FREQ_MIN / (SAMPLE_RATE/2)) * bufferLength);
      const maxBin = Math.round((FREQ_MAX / (SAMPLE_RATE/2)) * bufferLength);
      const binRange = maxBin - minBin;
      
      const width = canvas.width / binRange;
      
      for (let i = minBin; i < maxBin; i++) {
        const bin = i - minBin;
        const value = dataArray[i] / 255;
        const height = value * canvas.height;
        
        ctx.fillStyle = `hsl(${180 - value * 120}, 100%, 50%)`;
        ctx.fillRect(bin * width, canvas.height - height, width, height);
      }
      
      // Draw frequency labels
      ctx.fillStyle = '#666';
      ctx.font = '10px monospace';
      for (let f = 15; f <= 20; f += 1) {
        const x = ((f * 1000 - FREQ_MIN) / (FREQ_MAX - FREQ_MIN)) * canvas.width;
        ctx.fillText(`${f}k`, x - 10, canvas.height - 2);
      }
      
      this.updateDebug();
    };
    
    draw();
  }
}

// Start app
new ChatApp();
  </script>
</body>
</html>